N = c(100, 80, 30)
N
N.f = N/sum(N)
N.f
N.1.1 = c(60, 10, 0)
N.1.2 = c(40,70,30)
N.2.1 = c(80, 20, 0)
N.2.2 = c(20, 40, 0)
N.2.3 = c(0, 20, 30)
N^2
G.N = 1 - sum( ( N/sum(N) )^2 )
G.N
G.N.1.1 = 1 - sum( ( N.1.1/sum(N.1.1) )^2 )
gini <- function(N){
return 1 - sum( ( N/sum(N) )^2 )
gini <- function(N){
return (1 - sum( ( N/sum(N) )^2 ))
}
gini(N)
gini(N) - (sum(N.1.1)*gini(N.1.1) + sum(N.1.2)*gini(N.1.2))/(sum(N.1.1) + sum(N.1.2))
gini(N) - (sum(N.2.1)*gini(N.2.1) + sum(N.2.2)*gini(N.2.2) + sum(N.2.3)*gini(N.2.3))/( sum(N.2.1) + sum(N.2.2) + sum(N.2.3) )
25*2 + sum(N.1.1)*gini(N.1.1) + sum(N.1.2)*gini(N.1.2)
alpha = 25
alpha
cc = 25
cc.N.1 = cc*2 + sum(N.1.1)*gini(N.1.1) + sum(N.1.2)*gini(N.1.2)
cc.N.2 = cc*3 + sum(N.2.1)*gini(N.2.1) + sum(N.2.2)*gini(N.2.2) + sum(N.2.3)*gini(N.2.3)
cc.N.2
cc.N.1
log(N/sum(N)))
log(N)
N
e^3.4
exp(3.4)
N * N
(N * c(1, 2, 3))
sum(N)
-sum(N)
ent <- function(N){
return (-sum ( N/sum(N) * log(N/sum(N))) )
}
ent(N)
A = c(100, 0, 0)
ent(A)
A = c(100, 1, 1)
ent(A)
log(0)
ent(N.1.1)
entlog = log(N.1.1/sum(N.1.1))
entlog
entlog == -Inf
entlog = entlog[entlog == -Inf] <- 0
entlog
entlog[1]
entlog = log(N.1.1/sum(N.1.1))
entlog
entlog[1]
entlog[entlog == -Inf] <- 0
entlog
% hello
// hello
#shit
ent <- function(N){
entlog = log(N/sum(N))
# we have to replace -Infs with 0, otherwise R returns NaN
# this shouldn't affect the entropy measure, because if something
# is -Inf in entlog the value of it is 0, thus 0*-Inf in the entropy measure
# should still come out to 0
entlog[entlog == -Inf] <- 0
return (-sum ( N/sum(N) * entlog ) )
}
ent(N.1.1)
A
A = c(100, 0 ,0 ,0)
ent(A)
A[2] = 100
ent(A)
ent.H.1 = ent(N) - (sum(N.1.1)*ent(N.1.1) + sum(N.1.2)*ent(N.1.2))/(sum(N.1.1) + sum(N.1.2))
ent.H.2 = ent(N) - (sum(N.2.1)*ent(N.2.1) + sum(N.2.2)*ent(N.2.2) + sum(N.2.3)*ent(N.2.3))/( sum(N.2.1) + sum(N.2.2) + sum(N.2.3) )
ent.H.1
ent.H.2
cc = 25
cc.N.1 = cc*2 + sum(N.1.1)*ent(N.1.1) + sum(N.1.2)*ent(N.1.2)
cc.N.2 = cc*3 + sum(N.2.1)*ent(N.2.1) + sum(N.2.2)*ent(N.2.2) + sum(N.2.3)*ent(N.2.3)
cc.N.1
cc.N.2
mc_err <- function(N){
return (1 - max(N)/sum(N))
}
max(N)
mc_err(N)
mc_err.H.1 = mc_err(N) - (sum(N.1.1)*mc_err(N.1.1) + sum(N.1.2)*mc_err(N.1.2))/(sum(N.1.1) + sum(N.1.2))
mc_err.H.2 = mc_err(N) - (sum(N.2.1)*mc_err(N.2.1) + sum(N.2.2)*mc_err(N.2.2) + sum(N.2.3)*mc_err(N.2.3))/( sum(N.2.1) + sum(N.2.2) + sum(N.2.3) )
mc_err.H.1
mc_err.H.2
cc = 25
cc.N.1 = cc*2 + sum(N.1.1)*mc_err(N.1.1) + sum(N.1.2)*mc_err(N.1.2)
cc.N.2 = cc*3 + sum(N.2.1)*mc_err(N.2.1) + sum(N.2.2)*mc_err(N.2.2) + sum(N.2.3)*mc_err(N.2.3)
cc.N.1
cc.N.2
install.package(ElemStatLearn)
library(ElemStatLearn)
library(ElemStatLearn)
library()
search()
install.packages(ElemStatLearn)
install.packages(ElemStatLearn)
install.packages('ElemStatLearn')
library('ElemStatLearn')
?rpart
??rpart
spam
dim(spam)
head(spam)
install.packages('rpart')
library('rpart')
?rpart
\
rpart(spam, spam)
t = rpart(spam, spam)
t
describe(t)
plotcp(t)
